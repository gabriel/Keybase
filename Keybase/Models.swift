// This file is autogenerated

import SwiftyJSON


//
// Account
//


//
// Block
//

public typealias Time = Int64

public class StringKVPair {
	public let key: String?
	public let value: String?

	public init(key: String?, value: String?) {
		self.key = key
		self.value = value
	}

	public class func fromJSON(json: JSON) -> StringKVPair {
		return StringKVPair(key: json["key"].string, value: json["value"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [StringKVPair]? {
		return json?.map { fromJSON($0) }
	}
}


public class Status {
	public let code: Int32?
	public let name: String?
	public let desc: String?
	public let fields: [StringKVPair]?

	public init(code: Int32?, name: String?, desc: String?, fields: [StringKVPair]?) {
		self.code = code
		self.name = name
		self.desc = desc
		self.fields = fields
	}

	public class func fromJSON(json: JSON) -> Status {
		return Status(code: json["code"].int32, name: json["name"].string, desc: json["desc"].string, fields: StringKVPair.fromJSONArray(json["fields"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [Status]? {
		return json?.map { fromJSON($0) }
	}
}

public typealias UID = String
public typealias DeviceID = String
public typealias SigID = String
public typealias KID = String

public class Text {
	public let data: String?
	public let markup: Bool?

	public init(data: String?, markup: Bool?) {
		self.data = data
		self.markup = markup
	}

	public class func fromJSON(json: JSON) -> Text {
		return Text(data: json["data"].string, markup: json["markup"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Text]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPIdentity {
	public let username: String?
	public let comment: String?
	public let email: String?

	public init(username: String?, comment: String?, email: String?) {
		self.username = username
		self.comment = comment
		self.email = email
	}

	public class func fromJSON(json: JSON) -> PGPIdentity {
		return PGPIdentity(username: json["username"].string, comment: json["comment"].string, email: json["email"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPIdentity]? {
		return json?.map { fromJSON($0) }
	}
}


public class PublicKey {
	public let kid: String?
	public let PGPFingerprint: String?
	public let PGPIdentities: [PGPIdentity]?
	public let isSibkey: Bool?
	public let isEldest: Bool?
	public let parentID: String?
	public let deviceID: String?
	public let deviceDescription: String?
	public let deviceType: String?
	public let cTime: Int64?
	public let eTime: Int64?

	public init(kid: String?, PGPFingerprint: String?, PGPIdentities: [PGPIdentity]?, isSibkey: Bool?, isEldest: Bool?, parentID: String?, deviceID: String?, deviceDescription: String?, deviceType: String?, cTime: Int64?, eTime: Int64?) {
		self.kid = kid
		self.PGPFingerprint = PGPFingerprint
		self.PGPIdentities = PGPIdentities
		self.isSibkey = isSibkey
		self.isEldest = isEldest
		self.parentID = parentID
		self.deviceID = deviceID
		self.deviceDescription = deviceDescription
		self.deviceType = deviceType
		self.cTime = cTime
		self.eTime = eTime
	}

	public class func fromJSON(json: JSON) -> PublicKey {
		return PublicKey(kid: json["kid"].string, PGPFingerprint: json["PGPFingerprint"].string, PGPIdentities: PGPIdentity.fromJSONArray(json["PGPIdentities"].array), isSibkey: json["isSibkey"].bool, isEldest: json["isEldest"].bool, parentID: json["parentID"].string, deviceID: json["deviceID"].string, deviceDescription: json["deviceDescription"].string, deviceType: json["deviceType"].string, cTime: json["cTime"].int64, eTime: json["eTime"].int64)
	}

	public class func fromJSONArray(json: [JSON]?) -> [PublicKey]? {
		return json?.map { fromJSON($0) }
	}
}


public class User {
	public let uid: String?
	public let username: String?

	public init(uid: String?, username: String?) {
		self.uid = uid
		self.username = username
	}

	public class func fromJSON(json: JSON) -> User {
		return User(uid: json["uid"].string, username: json["username"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [User]? {
		return json?.map { fromJSON($0) }
	}
}


public class Device {
	public let type: String?
	public let name: String?
	public let deviceID: String?
	public let cTime: Int64?
	public let mTime: Int64?

	public init(type: String?, name: String?, deviceID: String?, cTime: Int64?, mTime: Int64?) {
		self.type = type
		self.name = name
		self.deviceID = deviceID
		self.cTime = cTime
		self.mTime = mTime
	}

	public class func fromJSON(json: JSON) -> Device {
		return Device(type: json["type"].string, name: json["name"].string, deviceID: json["deviceID"].string, cTime: json["cTime"].int64, mTime: json["mTime"].int64)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Device]? {
		return json?.map { fromJSON($0) }
	}
}


public class Stream {
	public let fd: Int32?

	public init(fd: Int32?) {
		self.fd = fd
	}

	public class func fromJSON(json: JSON) -> Stream {
		return Stream(fd: json["fd"].int32)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Stream]? {
		return json?.map { fromJSON($0) }
	}
}

public enum LogLevel: Int {
	case None = 0
	case Debug = 1
	case Info = 2
	case Notice = 3
	case Warn = 4
	case Error = 5
	case Critical = 6
	case Fatal = 7
}


public class BlockIdCombo {
	public let blockHash: String?
	public let chargedTo: String?

	public init(blockHash: String?, chargedTo: String?) {
		self.blockHash = blockHash
		self.chargedTo = chargedTo
	}

	public class func fromJSON(json: JSON) -> BlockIdCombo {
		return BlockIdCombo(blockHash: json["blockHash"].string, chargedTo: json["chargedTo"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [BlockIdCombo]? {
		return json?.map { fromJSON($0) }
	}
}


public class GetBlockRes {
	public let blockKey: String?
	public let buf: NSData?

	public init(blockKey: String?, buf: NSData?) {
		self.blockKey = blockKey
		self.buf = buf
	}

	public class func fromJSON(json: JSON) -> GetBlockRes {
		return GetBlockRes(blockKey: json["blockKey"].string, buf: NSData()/*TODO: Fixme*/)
	}

	public class func fromJSONArray(json: [JSON]?) -> [GetBlockRes]? {
		return json?.map { fromJSON($0) }
	}
}

public typealias BlockRefNonce = [UInt8] // Size: 8
//
// BTC
//


//
// Config
//


public class GetCurrentStatusRes {
	public let configured: Bool?
	public let registered: Bool?
	public let loggedIn: Bool?
	public let user: User?

	public init(configured: Bool?, registered: Bool?, loggedIn: Bool?, user: User?) {
		self.configured = configured
		self.registered = registered
		self.loggedIn = loggedIn
		self.user = user
	}

	public class func fromJSON(json: JSON) -> GetCurrentStatusRes {
		return GetCurrentStatusRes(configured: json["configured"].bool, registered: json["registered"].bool, loggedIn: json["loggedIn"].bool, user: User.fromJSON(json["user"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [GetCurrentStatusRes]? {
		return json?.map { fromJSON($0) }
	}
}


public class Config {
	public let serverURI: String?
	public let socketFile: String?
	public let label: String?
	public let runMode: String?
	public let gpgExists: Bool?
	public let gpgPath: String?
	public let version: String?
	public let path: String?
	public let configPath: String?

	public init(serverURI: String?, socketFile: String?, label: String?, runMode: String?, gpgExists: Bool?, gpgPath: String?, version: String?, path: String?, configPath: String?) {
		self.serverURI = serverURI
		self.socketFile = socketFile
		self.label = label
		self.runMode = runMode
		self.gpgExists = gpgExists
		self.gpgPath = gpgPath
		self.version = version
		self.path = path
		self.configPath = configPath
	}

	public class func fromJSON(json: JSON) -> Config {
		return Config(serverURI: json["serverURI"].string, socketFile: json["socketFile"].string, label: json["label"].string, runMode: json["runMode"].string, gpgExists: json["gpgExists"].bool, gpgPath: json["gpgPath"].string, version: json["version"].string, path: json["path"].string, configPath: json["configPath"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Config]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Crypto
//

public typealias ED25519PublicKey = [UInt8] // Size: 32
public typealias ED25519Signature = [UInt8] // Size: 64

public class ED25519SignatureInfo {
	public let sig: NSData?
	public let publicKey: NSData?

	public init(sig: NSData?, publicKey: NSData?) {
		self.sig = sig
		self.publicKey = publicKey
	}

	public class func fromJSON(json: JSON) -> ED25519SignatureInfo {
		return ED25519SignatureInfo(sig: NSData()/*TODO: Fixme*/, publicKey: NSData()/*TODO: Fixme*/)
	}

	public class func fromJSONArray(json: [JSON]?) -> [ED25519SignatureInfo]? {
		return json?.map { fromJSON($0) }
	}
}

public typealias Bytes32 = [UInt8] // Size: 32
public typealias EncryptedBytes32 = [UInt8] // Size: 48
public typealias BoxNonce = [UInt8] // Size: 24
public typealias BoxPublicKey = [UInt8] // Size: 32
//
// Ctl
//


//
// Debugging
//


public class FirstStepResult {
	public let valPlusTwo: Int32?

	public init(valPlusTwo: Int32?) {
		self.valPlusTwo = valPlusTwo
	}

	public class func fromJSON(json: JSON) -> FirstStepResult {
		return FirstStepResult(valPlusTwo: json["valPlusTwo"].int32)
	}

	public class func fromJSONArray(json: [JSON]?) -> [FirstStepResult]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Device
//


//
// Doctor
//


//
// DoctorUi
//

public enum DoctorFixType: Int {
	case None = 0
	case AddEldestDevice = 1
	case AddSiblingDevice = 2
}


public class DoctorSignerOpts {
	public let otherDevice: Bool?
	public let pgp: Bool?
	public let isInternal: Bool?

	public init(otherDevice: Bool?, pgp: Bool?, isInternal: Bool?) {
		self.otherDevice = otherDevice
		self.pgp = pgp
		self.isInternal = isInternal
	}

	public class func fromJSON(json: JSON) -> DoctorSignerOpts {
		return DoctorSignerOpts(otherDevice: json["otherDevice"].bool, pgp: json["pgp"].bool, isInternal: json["isInternal"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [DoctorSignerOpts]? {
		return json?.map { fromJSON($0) }
	}
}


public class DoctorStatus {
	public let fix: DoctorFixType?
	public let signerOpts: DoctorSignerOpts?
	public let devices: [Device]?
	public let currentDevice: Device?

	public init(fix: DoctorFixType?, signerOpts: DoctorSignerOpts?, devices: [Device]?, currentDevice: Device?) {
		self.fix = fix
		self.signerOpts = signerOpts
		self.devices = devices
		self.currentDevice = currentDevice
	}

	public class func fromJSON(json: JSON) -> DoctorStatus {
		return DoctorStatus(fix: DoctorFixType(rawValue: json["fix"].int!), signerOpts: DoctorSignerOpts.fromJSON(json["signerOpts"]), devices: Device.fromJSONArray(json["devices"].array), currentDevice: Device.fromJSON(json["currentDevice"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [DoctorStatus]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Favorite
//


public class Folder {
	public let name: String?
	public let isPrivate: Bool?
	public let notificationsOn: Bool?

	public init(name: String?, isPrivate: Bool?, notificationsOn: Bool?) {
		self.name = name
		self.isPrivate = isPrivate
		self.notificationsOn = notificationsOn
	}

	public class func fromJSON(json: JSON) -> Folder {
		return Folder(name: json["name"].string, isPrivate: json["isPrivate"].bool, notificationsOn: json["notificationsOn"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Folder]? {
		return json?.map { fromJSON($0) }
	}
}

//
// GpgUi
//


public class GPGKey {
	public let algorithm: String?
	public let keyID: String?
	public let creation: String?
	public let expiration: String?
	public let identities: [PGPIdentity]?

	public init(algorithm: String?, keyID: String?, creation: String?, expiration: String?, identities: [PGPIdentity]?) {
		self.algorithm = algorithm
		self.keyID = keyID
		self.creation = creation
		self.expiration = expiration
		self.identities = identities
	}

	public class func fromJSON(json: JSON) -> GPGKey {
		return GPGKey(algorithm: json["algorithm"].string, keyID: json["keyID"].string, creation: json["creation"].string, expiration: json["expiration"].string, identities: PGPIdentity.fromJSONArray(json["identities"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [GPGKey]? {
		return json?.map { fromJSON($0) }
	}
}


public class SelectKeyRes {
	public let keyID: String?
	public let doSecretPush: Bool?

	public init(keyID: String?, doSecretPush: Bool?) {
		self.keyID = keyID
		self.doSecretPush = doSecretPush
	}

	public class func fromJSON(json: JSON) -> SelectKeyRes {
		return SelectKeyRes(keyID: json["keyID"].string, doSecretPush: json["doSecretPush"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SelectKeyRes]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Identify
//

public enum ProofState: Int {
	case None = 0
	case Ok = 1
	case TempFailure = 2
	case PermFailure = 3
	case Looking = 4
	case Superseded = 5
	case Posted = 6
	case Revoked = 7
}

public enum ProofStatus: Int {
	case None = 0
	case Ok = 1
	case Local = 2
	case Found = 3
	case BaseError = 100
	case HostUnreachable = 101
	case PermissionDenied = 103
	case FailedParse = 106
	case DnsError = 107
	case AuthFailed = 108
	case Http500 = 150
	case Timeout = 160
	case InternalError = 170
	case BaseHardError = 200
	case NotFound = 201
	case ContentFailure = 202
	case BadUsername = 203
	case BadRemoteId = 204
	case TextNotFound = 205
	case BadArgs = 206
	case ContentMissing = 207
	case TitleNotFound = 208
	case ServiceError = 209
	case TorSkipped = 210
	case TorIncompatible = 211
	case Http300 = 230
	case Http400 = 240
	case HttpOther = 260
	case EmptyJson = 270
	case Deleted = 301
	case ServiceDead = 302
	case BadSignature = 303
	case BadApiUrl = 304
	case UnknownType = 305
	case NoHint = 306
	case BadHintText = 307
}

public enum ProofType: Int {
	case None = 0
	case Keybase = 1
	case Twitter = 2
	case Github = 3
	case Reddit = 4
	case Coinbase = 5
	case Hackernews = 6
	case GenericWebSite = 1000
	case Dns = 1001
	case Rooter = 100001
}

public enum TrackDiffType: Int {
	case None = 0
	case Error = 1
	case Clash = 2
	case Revoked = 3
	case Upgraded = 4
	case New = 5
	case RemoteFail = 6
	case RemoteWorking = 7
	case RemoteChanged = 8
}


public class TrackDiff {
	public let type: TrackDiffType?
	public let displayMarkup: String?

	public init(type: TrackDiffType?, displayMarkup: String?) {
		self.type = type
		self.displayMarkup = displayMarkup
	}

	public class func fromJSON(json: JSON) -> TrackDiff {
		return TrackDiff(type: TrackDiffType(rawValue: json["type"].int!), displayMarkup: json["displayMarkup"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [TrackDiff]? {
		return json?.map { fromJSON($0) }
	}
}


public class TrackSummary {
	public let username: String?
	public let time: Int64?
	public let isRemote: Bool?

	public init(username: String?, time: Int64?, isRemote: Bool?) {
		self.username = username
		self.time = time
		self.isRemote = isRemote
	}

	public class func fromJSON(json: JSON) -> TrackSummary {
		return TrackSummary(username: json["username"].string, time: json["time"].int64, isRemote: json["isRemote"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [TrackSummary]? {
		return json?.map { fromJSON($0) }
	}
}

public enum TrackStatus: Int {
	case NewOk = 1
	case NewZeroProofs = 2
	case NewFailProofs = 3
	case UpdateBroken = 4
	case UpdateNewProofs = 5
	case UpdateOk = 6
}


public class TrackOptions {
	public let localOnly: Bool?
	public let bypassConfirm: Bool?

	public init(localOnly: Bool?, bypassConfirm: Bool?) {
		self.localOnly = localOnly
		self.bypassConfirm = bypassConfirm
	}

	public class func fromJSON(json: JSON) -> TrackOptions {
		return TrackOptions(localOnly: json["localOnly"].bool, bypassConfirm: json["bypassConfirm"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [TrackOptions]? {
		return json?.map { fromJSON($0) }
	}
}


public class IdentifyOutcome {
	public let username: String?
	public let status: Status?
	public let warnings: [String]?
	public let trackUsed: TrackSummary?
	public let trackStatus: TrackStatus?
	public let numTrackFailures: Int32?
	public let numTrackChanges: Int32?
	public let numProofFailures: Int32?
	public let numRevoked: Int32?
	public let numProofSuccesses: Int32?
	public let revoked: [TrackDiff]?
	public let trackOptions: TrackOptions?

	public init(username: String?, status: Status?, warnings: [String]?, trackUsed: TrackSummary?, trackStatus: TrackStatus?, numTrackFailures: Int32?, numTrackChanges: Int32?, numProofFailures: Int32?, numRevoked: Int32?, numProofSuccesses: Int32?, revoked: [TrackDiff]?, trackOptions: TrackOptions?) {
		self.username = username
		self.status = status
		self.warnings = warnings
		self.trackUsed = trackUsed
		self.trackStatus = trackStatus
		self.numTrackFailures = numTrackFailures
		self.numTrackChanges = numTrackChanges
		self.numProofFailures = numProofFailures
		self.numRevoked = numRevoked
		self.numProofSuccesses = numProofSuccesses
		self.revoked = revoked
		self.trackOptions = trackOptions
	}

	public class func fromJSON(json: JSON) -> IdentifyOutcome {
		return IdentifyOutcome(username: json["username"].string, status: Status.fromJSON(json["status"]), warnings: String.fromJSONArray(json["warnings"].array), trackUsed: TrackSummary.fromJSON(json["trackUsed"]), trackStatus: TrackStatus(rawValue: json["trackStatus"].int!), numTrackFailures: json["numTrackFailures"].int32, numTrackChanges: json["numTrackChanges"].int32, numProofFailures: json["numProofFailures"].int32, numRevoked: json["numRevoked"].int32, numProofSuccesses: json["numProofSuccesses"].int32, revoked: TrackDiff.fromJSONArray(json["revoked"].array), trackOptions: TrackOptions.fromJSON(json["trackOptions"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [IdentifyOutcome]? {
		return json?.map { fromJSON($0) }
	}
}


public class IdentifyRes {
	public let user: User?
	public let publicKeys: [PublicKey]?
	public let outcome: IdentifyOutcome?
	public let trackToken: String?

	public init(user: User?, publicKeys: [PublicKey]?, outcome: IdentifyOutcome?, trackToken: String?) {
		self.user = user
		self.publicKeys = publicKeys
		self.outcome = outcome
		self.trackToken = trackToken
	}

	public class func fromJSON(json: JSON) -> IdentifyRes {
		return IdentifyRes(user: User.fromJSON(json["user"]), publicKeys: PublicKey.fromJSONArray(json["publicKeys"].array), outcome: IdentifyOutcome.fromJSON(json["outcome"]), trackToken: json["trackToken"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [IdentifyRes]? {
		return json?.map { fromJSON($0) }
	}
}


public class RemoteProof {
	public let proofType: ProofType?
	public let key: String?
	public let value: String?
	public let displayMarkup: String?
	public let sigID: String?
	public let mTime: Int64?

	public init(proofType: ProofType?, key: String?, value: String?, displayMarkup: String?, sigID: String?, mTime: Int64?) {
		self.proofType = proofType
		self.key = key
		self.value = value
		self.displayMarkup = displayMarkup
		self.sigID = sigID
		self.mTime = mTime
	}

	public class func fromJSON(json: JSON) -> RemoteProof {
		return RemoteProof(proofType: ProofType(rawValue: json["proofType"].int!), key: json["key"].string, value: json["value"].string, displayMarkup: json["displayMarkup"].string, sigID: json["sigID"].string, mTime: json["mTime"].int64)
	}

	public class func fromJSONArray(json: [JSON]?) -> [RemoteProof]? {
		return json?.map { fromJSON($0) }
	}
}

//
// IdentifyUi
//


public class ProofResult {
	public let state: ProofState?
	public let status: ProofStatus?
	public let desc: String?

	public init(state: ProofState?, status: ProofStatus?, desc: String?) {
		self.state = state
		self.status = status
		self.desc = desc
	}

	public class func fromJSON(json: JSON) -> ProofResult {
		return ProofResult(state: ProofState(rawValue: json["state"].int!), status: ProofStatus(rawValue: json["status"].int!), desc: json["desc"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [ProofResult]? {
		return json?.map { fromJSON($0) }
	}
}


public class IdentifyRow {
	public let rowId: Int32?
	public let proof: RemoteProof?
	public let trackDiff: TrackDiff?

	public init(rowId: Int32?, proof: RemoteProof?, trackDiff: TrackDiff?) {
		self.rowId = rowId
		self.proof = proof
		self.trackDiff = trackDiff
	}

	public class func fromJSON(json: JSON) -> IdentifyRow {
		return IdentifyRow(rowId: json["rowId"].int32, proof: RemoteProof.fromJSON(json["proof"]), trackDiff: TrackDiff.fromJSON(json["trackDiff"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [IdentifyRow]? {
		return json?.map { fromJSON($0) }
	}
}


public class IdentifyKey {
	public let pgpFingerprint: NSData?
	public let kid: String?
	public let trackDiff: TrackDiff?

	public init(pgpFingerprint: NSData?, kid: String?, trackDiff: TrackDiff?) {
		self.pgpFingerprint = pgpFingerprint
		self.kid = kid
		self.trackDiff = trackDiff
	}

	public class func fromJSON(json: JSON) -> IdentifyKey {
		return IdentifyKey(pgpFingerprint: NSData()/*TODO: Fixme*/, kid: json["kid"].string, trackDiff: TrackDiff.fromJSON(json["trackDiff"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [IdentifyKey]? {
		return json?.map { fromJSON($0) }
	}
}


public class Cryptocurrency {
	public let rowId: Int32?
	public let pkhash: NSData?
	public let address: String?

	public init(rowId: Int32?, pkhash: NSData?, address: String?) {
		self.rowId = rowId
		self.pkhash = pkhash
		self.address = address
	}

	public class func fromJSON(json: JSON) -> Cryptocurrency {
		return Cryptocurrency(rowId: json["rowId"].int32, pkhash: NSData()/*TODO: Fixme*/, address: json["address"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Cryptocurrency]? {
		return json?.map { fromJSON($0) }
	}
}


public class Identity {
	public let status: Status?
	public let whenLastTracked: Int32?
	public let proofs: [IdentifyRow]?
	public let cryptocurrency: [Cryptocurrency]?
	public let revoked: [TrackDiff]?

	public init(status: Status?, whenLastTracked: Int32?, proofs: [IdentifyRow]?, cryptocurrency: [Cryptocurrency]?, revoked: [TrackDiff]?) {
		self.status = status
		self.whenLastTracked = whenLastTracked
		self.proofs = proofs
		self.cryptocurrency = cryptocurrency
		self.revoked = revoked
	}

	public class func fromJSON(json: JSON) -> Identity {
		return Identity(status: Status.fromJSON(json["status"]), whenLastTracked: json["whenLastTracked"].int32, proofs: IdentifyRow.fromJSONArray(json["proofs"].array), cryptocurrency: Cryptocurrency.fromJSONArray(json["cryptocurrency"].array), revoked: TrackDiff.fromJSONArray(json["revoked"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [Identity]? {
		return json?.map { fromJSON($0) }
	}
}


public class SigHint {
	public let remoteId: String?
	public let humanUrl: String?
	public let apiUrl: String?
	public let checkText: String?

	public init(remoteId: String?, humanUrl: String?, apiUrl: String?, checkText: String?) {
		self.remoteId = remoteId
		self.humanUrl = humanUrl
		self.apiUrl = apiUrl
		self.checkText = checkText
	}

	public class func fromJSON(json: JSON) -> SigHint {
		return SigHint(remoteId: json["remoteId"].string, humanUrl: json["humanUrl"].string, apiUrl: json["apiUrl"].string, checkText: json["checkText"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SigHint]? {
		return json?.map { fromJSON($0) }
	}
}


public class CheckResult {
	public let proofResult: ProofResult?
	public let time: Int64?
	public let displayMarkup: String?

	public init(proofResult: ProofResult?, time: Int64?, displayMarkup: String?) {
		self.proofResult = proofResult
		self.time = time
		self.displayMarkup = displayMarkup
	}

	public class func fromJSON(json: JSON) -> CheckResult {
		return CheckResult(proofResult: ProofResult.fromJSON(json["proofResult"]), time: json["time"].int64, displayMarkup: json["displayMarkup"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [CheckResult]? {
		return json?.map { fromJSON($0) }
	}
}


public class LinkCheckResult {
	public let proofId: Int32?
	public let proofResult: ProofResult?
	public let cached: CheckResult?
	public let diff: TrackDiff?
	public let remoteDiff: TrackDiff?
	public let hint: SigHint?

	public init(proofId: Int32?, proofResult: ProofResult?, cached: CheckResult?, diff: TrackDiff?, remoteDiff: TrackDiff?, hint: SigHint?) {
		self.proofId = proofId
		self.proofResult = proofResult
		self.cached = cached
		self.diff = diff
		self.remoteDiff = remoteDiff
		self.hint = hint
	}

	public class func fromJSON(json: JSON) -> LinkCheckResult {
		return LinkCheckResult(proofId: json["proofId"].int32, proofResult: ProofResult.fromJSON(json["proofResult"]), cached: CheckResult.fromJSON(json["cached"]), diff: TrackDiff.fromJSON(json["diff"]), remoteDiff: TrackDiff.fromJSON(json["remoteDiff"]), hint: SigHint.fromJSON(json["hint"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [LinkCheckResult]? {
		return json?.map { fromJSON($0) }
	}
}

//
// LocksmithUi
//

public enum DeviceSignerKind: Int {
	case Device = 0
	case Pgp = 1
	case PaperBackupKey = 2
}

public enum SelectSignerAction: Int {
	case Sign = 0
	case Cancel = 1
}


public class DeviceSigner {
	public let kind: DeviceSignerKind?
	public let deviceID: String?
	public let deviceName: String?

	public init(kind: DeviceSignerKind?, deviceID: String?, deviceName: String?) {
		self.kind = kind
		self.deviceID = deviceID
		self.deviceName = deviceName
	}

	public class func fromJSON(json: JSON) -> DeviceSigner {
		return DeviceSigner(kind: DeviceSignerKind(rawValue: json["kind"].int!), deviceID: json["deviceID"].string, deviceName: json["deviceName"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [DeviceSigner]? {
		return json?.map { fromJSON($0) }
	}
}


public class SelectSignerRes {
	public let action: SelectSignerAction?
	public let signer: DeviceSigner?

	public init(action: SelectSignerAction?, signer: DeviceSigner?) {
		self.action = action
		self.signer = signer
	}

	public class func fromJSON(json: JSON) -> SelectSignerRes {
		return SelectSignerRes(action: SelectSignerAction(rawValue: json["action"].int!), signer: DeviceSigner.fromJSON(json["signer"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [SelectSignerRes]? {
		return json?.map { fromJSON($0) }
	}
}

public enum KexStatusCode: Int {
	case StartSend = 0
	case HelloWait = 1
	case HelloReceived = 2
	case PleaseSignSend = 3
	case DoneWait = 4
	case DoneReceived = 5
	case StartWait = 6
	case StartReceived = 7
	case HelloSend = 8
	case PleaseSignWait = 9
	case PleaseSignReceived = 10
	case DoneSend = 11
	case End = 12
}

//
// LogUi
//


//
// Login
//


public class ConfiguredAccount {
	public let username: String?
	public let hasStoredSecret: Bool?

	public init(username: String?, hasStoredSecret: Bool?) {
		self.username = username
		self.hasStoredSecret = hasStoredSecret
	}

	public class func fromJSON(json: JSON) -> ConfiguredAccount {
		return ConfiguredAccount(username: json["username"].string, hasStoredSecret: json["hasStoredSecret"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [ConfiguredAccount]? {
		return json?.map { fromJSON($0) }
	}
}

//
// LoginUi
//


//
// Metadata
//


public class KeyHalf {
	public let user: String?
	public let deviceKID: String?
	public let key: NSData?

	public init(user: String?, deviceKID: String?, key: NSData?) {
		self.user = user
		self.deviceKID = deviceKID
		self.key = key
	}

	public class func fromJSON(json: JSON) -> KeyHalf {
		return KeyHalf(user: json["user"].string, deviceKID: json["deviceKID"].string, key: NSData()/*TODO: Fixme*/)
	}

	public class func fromJSONArray(json: [JSON]?) -> [KeyHalf]? {
		return json?.map { fromJSON($0) }
	}
}


public class MetadataResponse {
	public let folderID: String?
	public let mdBlocks: [NSData]?

	public init(folderID: String?, mdBlocks: [NSData]?) {
		self.folderID = folderID
		self.mdBlocks = mdBlocks
	}

	public class func fromJSON(json: JSON) -> MetadataResponse {
		return MetadataResponse(folderID: json["folderID"].string, mdBlocks: NSData.fromJSONArray(json["mdBlocks"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [MetadataResponse]? {
		return json?.map { fromJSON($0) }
	}
}

//
// MetadataUpdate
//


//
// Pgp
//

public enum SignMode: Int {
	case Attached = 0
	case Detached = 1
	case Clear = 2
}


public class PGPSignOptions {
	public let keyQuery: String?
	public let mode: SignMode?
	public let binaryIn: Bool?
	public let binaryOut: Bool?

	public init(keyQuery: String?, mode: SignMode?, binaryIn: Bool?, binaryOut: Bool?) {
		self.keyQuery = keyQuery
		self.mode = mode
		self.binaryIn = binaryIn
		self.binaryOut = binaryOut
	}

	public class func fromJSON(json: JSON) -> PGPSignOptions {
		return PGPSignOptions(keyQuery: json["keyQuery"].string, mode: SignMode(rawValue: json["mode"].int!), binaryIn: json["binaryIn"].bool, binaryOut: json["binaryOut"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPSignOptions]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPEncryptOptions {
	public let recipients: [String]?
	public let noSign: Bool?
	public let noSelf: Bool?
	public let binaryOut: Bool?
	public let keyQuery: String?
	public let trackOptions: TrackOptions?

	public init(recipients: [String]?, noSign: Bool?, noSelf: Bool?, binaryOut: Bool?, keyQuery: String?, trackOptions: TrackOptions?) {
		self.recipients = recipients
		self.noSign = noSign
		self.noSelf = noSelf
		self.binaryOut = binaryOut
		self.keyQuery = keyQuery
		self.trackOptions = trackOptions
	}

	public class func fromJSON(json: JSON) -> PGPEncryptOptions {
		return PGPEncryptOptions(recipients: String.fromJSONArray(json["recipients"].array), noSign: json["noSign"].bool, noSelf: json["noSelf"].bool, binaryOut: json["binaryOut"].bool, keyQuery: json["keyQuery"].string, trackOptions: TrackOptions.fromJSON(json["trackOptions"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPEncryptOptions]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPSigVerification {
	public let isSigned: Bool?
	public let verified: Bool?
	public let signer: User?
	public let signKey: PublicKey?

	public init(isSigned: Bool?, verified: Bool?, signer: User?, signKey: PublicKey?) {
		self.isSigned = isSigned
		self.verified = verified
		self.signer = signer
		self.signKey = signKey
	}

	public class func fromJSON(json: JSON) -> PGPSigVerification {
		return PGPSigVerification(isSigned: json["isSigned"].bool, verified: json["verified"].bool, signer: User.fromJSON(json["signer"]), signKey: PublicKey.fromJSON(json["signKey"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPSigVerification]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPDecryptOptions {
	public let assertSigned: Bool?
	public let signedBy: String?
	public let trackOptions: TrackOptions?

	public init(assertSigned: Bool?, signedBy: String?, trackOptions: TrackOptions?) {
		self.assertSigned = assertSigned
		self.signedBy = signedBy
		self.trackOptions = trackOptions
	}

	public class func fromJSON(json: JSON) -> PGPDecryptOptions {
		return PGPDecryptOptions(assertSigned: json["assertSigned"].bool, signedBy: json["signedBy"].string, trackOptions: TrackOptions.fromJSON(json["trackOptions"]))
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPDecryptOptions]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPVerifyOptions {
	public let signedBy: String?
	public let trackOptions: TrackOptions?
	public let signature: NSData?

	public init(signedBy: String?, trackOptions: TrackOptions?, signature: NSData?) {
		self.signedBy = signedBy
		self.trackOptions = trackOptions
		self.signature = signature
	}

	public class func fromJSON(json: JSON) -> PGPVerifyOptions {
		return PGPVerifyOptions(signedBy: json["signedBy"].string, trackOptions: TrackOptions.fromJSON(json["trackOptions"]), signature: NSData()/*TODO: Fixme*/)
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPVerifyOptions]? {
		return json?.map { fromJSON($0) }
	}
}


public class KeyInfo {
	public let fingerprint: String?
	public let key: String?
	public let desc: String?

	public init(fingerprint: String?, key: String?, desc: String?) {
		self.fingerprint = fingerprint
		self.key = key
		self.desc = desc
	}

	public class func fromJSON(json: JSON) -> KeyInfo {
		return KeyInfo(fingerprint: json["fingerprint"].string, key: json["key"].string, desc: json["desc"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [KeyInfo]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPQuery {
	public let secret: Bool?
	public let query: String?
	public let exactMatch: Bool?

	public init(secret: Bool?, query: String?, exactMatch: Bool?) {
		self.secret = secret
		self.query = query
		self.exactMatch = exactMatch
	}

	public class func fromJSON(json: JSON) -> PGPQuery {
		return PGPQuery(secret: json["secret"].bool, query: json["query"].string, exactMatch: json["exactMatch"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPQuery]? {
		return json?.map { fromJSON($0) }
	}
}


public class PGPCreateUids {
	public let useDefault: Bool?
	public let ids: [PGPIdentity]?

	public init(useDefault: Bool?, ids: [PGPIdentity]?) {
		self.useDefault = useDefault
		self.ids = ids
	}

	public class func fromJSON(json: JSON) -> PGPCreateUids {
		return PGPCreateUids(useDefault: json["useDefault"].bool, ids: PGPIdentity.fromJSONArray(json["ids"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [PGPCreateUids]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Prove
//


public class CheckProofStatus {
	public let found: Bool?
	public let status: ProofStatus?
	public let proofText: String?

	public init(found: Bool?, status: ProofStatus?, proofText: String?) {
		self.found = found
		self.status = status
		self.proofText = proofText
	}

	public class func fromJSON(json: JSON) -> CheckProofStatus {
		return CheckProofStatus(found: json["found"].bool, status: ProofStatus(rawValue: json["status"].int!), proofText: json["proofText"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [CheckProofStatus]? {
		return json?.map { fromJSON($0) }
	}
}


public class StartProofResult {
	public let sigID: String?

	public init(sigID: String?) {
		self.sigID = sigID
	}

	public class func fromJSON(json: JSON) -> StartProofResult {
		return StartProofResult(sigID: json["sigID"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [StartProofResult]? {
		return json?.map { fromJSON($0) }
	}
}

//
// ProveUi
//

public enum PromptOverwriteType: Int {
	case Social = 0
	case Site = 1
}

//
// Quota
//


public class SessionToken {
	public let uid: String?
	public let sid: String?
	public let generated: Int32?
	public let lifetime: Int32?

	public init(uid: String?, sid: String?, generated: Int32?, lifetime: Int32?) {
		self.uid = uid
		self.sid = sid
		self.generated = generated
		self.lifetime = lifetime
	}

	public class func fromJSON(json: JSON) -> SessionToken {
		return SessionToken(uid: json["uid"].string, sid: json["sid"].string, generated: json["generated"].int32, lifetime: json["lifetime"].int32)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SessionToken]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Revoke
//


//
// SecretUi
//


public class SecretEntryArg {
	public let desc: String?
	public let prompt: String?
	public let err: String?
	public let cancel: String?
	public let ok: String?
	public let reason: String?
	public let useSecretStore: Bool?

	public init(desc: String?, prompt: String?, err: String?, cancel: String?, ok: String?, reason: String?, useSecretStore: Bool?) {
		self.desc = desc
		self.prompt = prompt
		self.err = err
		self.cancel = cancel
		self.ok = ok
		self.reason = reason
		self.useSecretStore = useSecretStore
	}

	public class func fromJSON(json: JSON) -> SecretEntryArg {
		return SecretEntryArg(desc: json["desc"].string, prompt: json["prompt"].string, err: json["err"].string, cancel: json["cancel"].string, ok: json["ok"].string, reason: json["reason"].string, useSecretStore: json["useSecretStore"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SecretEntryArg]? {
		return json?.map { fromJSON($0) }
	}
}


public class SecretEntryRes {
	public let text: String?
	public let canceled: Bool?
	public let storeSecret: Bool?

	public init(text: String?, canceled: Bool?, storeSecret: Bool?) {
		self.text = text
		self.canceled = canceled
		self.storeSecret = storeSecret
	}

	public class func fromJSON(json: JSON) -> SecretEntryRes {
		return SecretEntryRes(text: json["text"].string, canceled: json["canceled"].bool, storeSecret: json["storeSecret"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SecretEntryRes]? {
		return json?.map { fromJSON($0) }
	}
}


public class GetNewPassphraseRes {
	public let passphrase: String?
	public let storeSecret: Bool?

	public init(passphrase: String?, storeSecret: Bool?) {
		self.passphrase = passphrase
		self.storeSecret = storeSecret
	}

	public class func fromJSON(json: JSON) -> GetNewPassphraseRes {
		return GetNewPassphraseRes(passphrase: json["passphrase"].string, storeSecret: json["storeSecret"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [GetNewPassphraseRes]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Session
//


public class Session {
	public let uid: String?
	public let username: String?
	public let token: String?
	public let deviceSubkeyKid: String?

	public init(uid: String?, username: String?, token: String?, deviceSubkeyKid: String?) {
		self.uid = uid
		self.username = username
		self.token = token
		self.deviceSubkeyKid = deviceSubkeyKid
	}

	public class func fromJSON(json: JSON) -> Session {
		return Session(uid: json["uid"].string, username: json["username"].string, token: json["token"].string, deviceSubkeyKid: json["deviceSubkeyKid"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Session]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Signup
//


public class SignupRes {
	public let passphraseOk: Bool?
	public let postOk: Bool?
	public let writeOk: Bool?

	public init(passphraseOk: Bool?, postOk: Bool?, writeOk: Bool?) {
		self.passphraseOk = passphraseOk
		self.postOk = postOk
		self.writeOk = writeOk
	}

	public class func fromJSON(json: JSON) -> SignupRes {
		return SignupRes(passphraseOk: json["passphraseOk"].bool, postOk: json["postOk"].bool, writeOk: json["writeOk"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SignupRes]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Sigs
//


public class Sig {
	public let seqno: Int32?
	public let sigID: String?
	public let sigIDDisplay: String?
	public let type: String?
	public let cTime: Int64?
	public let revoked: Bool?
	public let active: Bool?
	public let key: String?
	public let body: String?

	public init(seqno: Int32?, sigID: String?, sigIDDisplay: String?, type: String?, cTime: Int64?, revoked: Bool?, active: Bool?, key: String?, body: String?) {
		self.seqno = seqno
		self.sigID = sigID
		self.sigIDDisplay = sigIDDisplay
		self.type = type
		self.cTime = cTime
		self.revoked = revoked
		self.active = active
		self.key = key
		self.body = body
	}

	public class func fromJSON(json: JSON) -> Sig {
		return Sig(seqno: json["seqno"].int32, sigID: json["sigID"].string, sigIDDisplay: json["sigIDDisplay"].string, type: json["type"].string, cTime: json["cTime"].int64, revoked: json["revoked"].bool, active: json["active"].bool, key: json["key"].string, body: json["body"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Sig]? {
		return json?.map { fromJSON($0) }
	}
}


public class SigTypes {
	public let track: Bool?
	public let proof: Bool?
	public let cryptocurrency: Bool?
	public let isSelf: Bool?

	public init(track: Bool?, proof: Bool?, cryptocurrency: Bool?, isSelf: Bool?) {
		self.track = track
		self.proof = proof
		self.cryptocurrency = cryptocurrency
		self.isSelf = isSelf
	}

	public class func fromJSON(json: JSON) -> SigTypes {
		return SigTypes(track: json["track"].bool, proof: json["proof"].bool, cryptocurrency: json["cryptocurrency"].bool, isSelf: json["isSelf"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SigTypes]? {
		return json?.map { fromJSON($0) }
	}
}


public class SigListArgs {
	public let sessionID: Int32?
	public let username: String?
	public let allKeys: Bool?
	public let types: SigTypes?
	public let filterx: String?
	public let verbose: Bool?
	public let revoked: Bool?

	public init(sessionID: Int32?, username: String?, allKeys: Bool?, types: SigTypes?, filterx: String?, verbose: Bool?, revoked: Bool?) {
		self.sessionID = sessionID
		self.username = username
		self.allKeys = allKeys
		self.types = types
		self.filterx = filterx
		self.verbose = verbose
		self.revoked = revoked
	}

	public class func fromJSON(json: JSON) -> SigListArgs {
		return SigListArgs(sessionID: json["sessionID"].int32, username: json["username"].string, allKeys: json["allKeys"].bool, types: SigTypes.fromJSON(json["types"]), filterx: json["filterx"].string, verbose: json["verbose"].bool, revoked: json["revoked"].bool)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SigListArgs]? {
		return json?.map { fromJSON($0) }
	}
}

//
// StreamUi
//


//
// Test
//


public class Test {
	public let reply: String?

	public init(reply: String?) {
		self.reply = reply
	}

	public class func fromJSON(json: JSON) -> Test {
		return Test(reply: json["reply"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Test]? {
		return json?.map { fromJSON($0) }
	}
}

//
// Track
//


//
// Ui
//

public enum PromptDefault: Int {
	case None = 0
	case Yes = 1
	case No = 2
}

//
// User
//


public class Tracker {
	public let tracker: String?
	public let status: Int32?
	public let mTime: Int64?

	public init(tracker: String?, status: Int32?, mTime: Int64?) {
		self.tracker = tracker
		self.status = status
		self.mTime = mTime
	}

	public class func fromJSON(json: JSON) -> Tracker {
		return Tracker(tracker: json["tracker"].string, status: json["status"].int32, mTime: json["mTime"].int64)
	}

	public class func fromJSONArray(json: [JSON]?) -> [Tracker]? {
		return json?.map { fromJSON($0) }
	}
}


public class TrackProof {
	public let proofType: String?
	public let proofName: String?
	public let idString: String?

	public init(proofType: String?, proofName: String?, idString: String?) {
		self.proofType = proofType
		self.proofName = proofName
		self.idString = idString
	}

	public class func fromJSON(json: JSON) -> TrackProof {
		return TrackProof(proofType: json["proofType"].string, proofName: json["proofName"].string, idString: json["idString"].string)
	}

	public class func fromJSONArray(json: [JSON]?) -> [TrackProof]? {
		return json?.map { fromJSON($0) }
	}
}


public class WebProof {
	public let hostname: String?
	public let protocols: [String]?

	public init(hostname: String?, protocols: [String]?) {
		self.hostname = hostname
		self.protocols = protocols
	}

	public class func fromJSON(json: JSON) -> WebProof {
		return WebProof(hostname: json["hostname"].string, protocols: String.fromJSONArray(json["protocols"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [WebProof]? {
		return json?.map { fromJSON($0) }
	}
}


public class Proofs {
	public let social: [TrackProof]?
	public let web: [WebProof]?
	public let publicKeys: [PublicKey]?

	public init(social: [TrackProof]?, web: [WebProof]?, publicKeys: [PublicKey]?) {
		self.social = social
		self.web = web
		self.publicKeys = publicKeys
	}

	public class func fromJSON(json: JSON) -> Proofs {
		return Proofs(social: TrackProof.fromJSONArray(json["social"].array), web: WebProof.fromJSONArray(json["web"].array), publicKeys: PublicKey.fromJSONArray(json["publicKeys"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [Proofs]? {
		return json?.map { fromJSON($0) }
	}
}


public class UserSummary {
	public let uid: String?
	public let username: String?
	public let idVersion: Int32?
	public let fullName: String?
	public let bio: String?
	public let proofs: Proofs?
	public let sigIDDisplay: String?
	public let trackTime: Int64?

	public init(uid: String?, username: String?, idVersion: Int32?, fullName: String?, bio: String?, proofs: Proofs?, sigIDDisplay: String?, trackTime: Int64?) {
		self.uid = uid
		self.username = username
		self.idVersion = idVersion
		self.fullName = fullName
		self.bio = bio
		self.proofs = proofs
		self.sigIDDisplay = sigIDDisplay
		self.trackTime = trackTime
	}

	public class func fromJSON(json: JSON) -> UserSummary {
		return UserSummary(uid: json["uid"].string, username: json["username"].string, idVersion: json["idVersion"].int32, fullName: json["fullName"].string, bio: json["bio"].string, proofs: Proofs.fromJSON(json["proofs"]), sigIDDisplay: json["sigIDDisplay"].string, trackTime: json["trackTime"].int64)
	}

	public class func fromJSONArray(json: [JSON]?) -> [UserSummary]? {
		return json?.map { fromJSON($0) }
	}
}


public class UserPlusKeys {
	public let uid: String?
	public let username: String?
	public let deviceKeys: [PublicKey]?

	public init(uid: String?, username: String?, deviceKeys: [PublicKey]?) {
		self.uid = uid
		self.username = username
		self.deviceKeys = deviceKeys
	}

	public class func fromJSON(json: JSON) -> UserPlusKeys {
		return UserPlusKeys(uid: json["uid"].string, username: json["username"].string, deviceKeys: PublicKey.fromJSONArray(json["deviceKeys"].array))
	}

	public class func fromJSONArray(json: [JSON]?) -> [UserPlusKeys]? {
		return json?.map { fromJSON($0) }
	}
}


public class SearchComponent {
	public let key: String?
	public let value: String?
	public let score: Double?

	public init(key: String?, value: String?, score: Double?) {
		self.key = key
		self.value = value
		self.score = score
	}

	public class func fromJSON(json: JSON) -> SearchComponent {
		return SearchComponent(key: json["key"].string, value: json["value"].string, score: json["score"].double)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SearchComponent]? {
		return json?.map { fromJSON($0) }
	}
}


public class SearchResult {
	public let uid: String?
	public let username: String?
	public let components: [SearchComponent]?
	public let score: Double?

	public init(uid: String?, username: String?, components: [SearchComponent]?, score: Double?) {
		self.uid = uid
		self.username = username
		self.components = components
		self.score = score
	}

	public class func fromJSON(json: JSON) -> SearchResult {
		return SearchResult(uid: json["uid"].string, username: json["username"].string, components: SearchComponent.fromJSONArray(json["components"].array), score: json["score"].double)
	}

	public class func fromJSONArray(json: [JSON]?) -> [SearchResult]? {
		return json?.map { fromJSON($0) }
	}
}
